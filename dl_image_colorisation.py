# -*- coding: utf-8 -*-
"""DL Image colorisation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aZF-aEI9olfO5n_pQ4xQqz6eN81_Pvxe
"""

!pip install kaggle

from google.colab import files
files.upload()

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d aayush9753/image-colorization-dataset

!unzip -q image-colorization-dataset.zip -d /content/image_colorization_data

import os
os.listdir('/content/image_colorization_data')

# ==============================================================
# ðŸŽ¨ IMAGE COLORIZATION USING CONVOLUTIONAL AUTOENCODER (U-NET STYLE)
# ==============================================================

import tensorflow as tf
import numpy as np
import os
import matplotlib.pyplot as plt
import cv2
import imageio
from tensorflow.keras.layers import Input, Conv2D, MaxPool2D, UpSampling2D, Concatenate
from tensorflow.keras.models import Model
from skimage.metrics import structural_similarity as ssim, peak_signal_noise_ratio as psnr

# --------------------------------------------------------------
# ðŸ”§ Setup paths and parameters
# --------------------------------------------------------------
data_root = '/content/image_colorization_data'  # <-- change to your dataset folder
train_color = os.path.join(data_root, '/content/image_colorization_data/data/train_color')
train_black = os.path.join(data_root, '/content/image_colorization_data/data/train_black')
test_color = os.path.join(data_root, '/content/image_colorization_data/data/test_color')
test_black = os.path.join(data_root, '/content/image_colorization_data/data/test_black')

batch_size = 16
img_height, img_width = 256, 256

# --------------------------------------------------------------
# ðŸŒ€ Data Generator
# --------------------------------------------------------------
def image_batch_generator(color_dir, black_dir, img_height, img_width, batch_size):
    color_filenames = sorted([os.path.join(color_dir, fn) for fn in os.listdir(color_dir)])
    black_filenames = sorted([os.path.join(black_dir, fn) for fn in os.listdir(black_dir)])
    while True:
        for i in range(0, len(color_filenames), batch_size):
            batch_color, batch_black = [], []
            for cpath, bpath in zip(color_filenames[i:i+batch_size], black_filenames[i:i+batch_size]):
                c = tf.io.read_file(cpath)
                c = tf.image.decode_jpeg(c, channels=3)
                c = tf.image.resize(c, [img_height, img_width]) / 255.0
                batch_color.append(c)

                b = tf.io.read_file(bpath)
                b = tf.image.decode_jpeg(b, channels=1)
                b = tf.image.resize(b, [img_height, img_width]) / 255.0
                batch_black.append(b)
            yield np.array(batch_black), np.array(batch_color)

# --------------------------------------------------------------
# ðŸ§© Define the Model (U-Net style Autoencoder)
# --------------------------------------------------------------
def build_autoencoder(img_height, img_width):
    inputs = Input(shape=(img_height, img_width, 1))
    c1 = Conv2D(64, (3,3), padding='same', activation='relu')(inputs)
    p1 = MaxPool2D((2,2))(c1)
    c2 = Conv2D(32, (3,3), padding='same', activation='relu')(p1)
    p2 = MaxPool2D((2,2))(c2)
    c3 = Conv2D(16, (3,3), padding='same', activation='relu')(p2)
    p3 = MaxPool2D((2,2))(c3)

    encoded = Conv2D(8, (3,3), padding='same', activation='relu')(p3)

    u1 = UpSampling2D((2,2))(encoded)
    u1 = Conv2D(16, (3,3), padding='same', activation='relu')(u1)
    u1 = Concatenate()([u1, c3])
    u2 = UpSampling2D((2,2))(u1)
    u2 = Conv2D(32, (3,3), padding='same', activation='relu')(u2)
    u2 = Concatenate()([u2, c2])
    u3 = UpSampling2D((2,2))(u2)
    u3 = Conv2D(64, (3,3), padding='same', activation='relu')(u3)
    u3 = Concatenate()([u3, c1])

    outputs = Conv2D(3, (3,3), padding='same', activation='sigmoid')(u3)

    model = Model(inputs, outputs)
    model.compile(optimizer='adam', loss='mse')
    return model

# --------------------------------------------------------------
# ðŸš€ Train the Model
# --------------------------------------------------------------
dataset = image_batch_generator(train_color, train_black, img_height, img_width, batch_size)
autoencoder = build_autoencoder(img_height, img_width)
steps_per_epoch = len(os.listdir(train_color)) // batch_size
autoencoder.fit(dataset, steps_per_epoch=steps_per_epoch, epochs=20)

# --------------------------------------------------------------
# ðŸŽ¯ Test on One Image
# --------------------------------------------------------------
bnw_batch, color_batch = next(dataset)
single_bw = np.expand_dims(bnw_batch[0], axis=0)
pred = autoencoder.predict(single_bw)[0]

plt.figure(figsize=(10,3))
plt.subplot(1,3,1)
plt.imshow(bnw_batch[0].squeeze(), cmap='gray')
plt.title('Grayscale')
plt.axis('off')
plt.subplot(1,3,2)
plt.imshow(color_batch[0])
plt.title('Ground Truth')
plt.axis('off')
plt.subplot(1,3,3)
plt.imshow(pred)
plt.title('Predicted')
plt.axis('off')
plt.show()

# --------------------------------------------------------------
# ðŸ’¾ Save Model
# --------------------------------------------------------------
autoencoder.save('/content/drive/MyDrive/colorization_model.h5')

# --------------------------------------------------------------
# ðŸ§ƒ Colorize All Test Images
# --------------------------------------------------------------
out_folder = '/content/drive/MyDrive/colorized_results'
os.makedirs(out_folder, exist_ok=True)
black_list = sorted(os.listdir(test_black))

for fname in black_list:
    bpath = os.path.join(test_black, fname)
    b = tf.io.read_file(bpath)
    b = tf.image.decode_jpeg(b, channels=1)
    b = tf.image.resize(b, [img_height, img_width]) / 255.0
    b = tf.expand_dims(b, axis=0)
    pred = autoencoder.predict(b)[0]
    pred_img = (pred * 255).astype(np.uint8)
    imageio.imwrite(os.path.join(out_folder, fname), pred_img)

# --------------------------------------------------------------
# ðŸ–¼ï¸ Display a Few Colorized Outputs
# --------------------------------------------------------------
result_files = sorted(os.listdir(out_folder))
for fname in result_files[:5]:
    img_path = os.path.join(out_folder, fname)
    img = cv2.imread(img_path)
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    plt.figure(figsize=(4,4))
    plt.imshow(img)
    plt.title(fname)
    plt.axis('off')
    plt.show()

# --------------------------------------------------------------
# ðŸ“ˆ Evaluate SSIM and PSNR
# --------------------------------------------------------------
color_list = sorted(os.listdir(test_color))
pred_list = sorted(os.listdir(out_folder))
total_ssim = 0
total_psnr = 0

for cfile, pfile in zip(color_list, pred_list):
    c_img = cv2.imread(os.path.join(test_color, cfile))
    p_img = cv2.imread(os.path.join(out_folder, pfile))
    c_img = cv2.resize(c_img, (256, 256))
    p_img = cv2.resize(p_img, (256, 256))
    total_ssim += ssim(c_img, p_img, channel_axis=-1, data_range=255)
    total_psnr += psnr(c_img, p_img, data_range=255)

print("âœ… Average SSIM:", total_ssim / len(color_list))
print("âœ… Average PSNR:", total_psnr / len(color_list))

# --------------------------------------------------------------
# ðŸ“¦ Zip and Download Colorized Results
# --------------------------------------------------------------
!zip -r colorized_results.zip '/content/drive/MyDrive/colorized_results'
from google.colab import files
files.download('colorized_results.zip')

# ==============================================================
# ðŸŽ¨ IMAGE COLORIZATION USING CONVOLUTIONAL AUTOENCODER (U-NET STYLE)
# ==============================================================

import tensorflow as tf
import numpy as np
import os
import matplotlib.pyplot as plt
import cv2
import imageio
from tensorflow.keras.layers import Input, Conv2D, MaxPool2D, UpSampling2D, Concatenate
from tensorflow.keras.models import Model
from skimage.metrics import structural_similarity as ssim, peak_signal_noise_ratio as psnr

# --------------------------------------------------------------
# ðŸ”§ Setup paths and parameters
# --------------------------------------------------------------
data_root = '/content/image_colorization_data'  # <-- change to your dataset folder
train_color = os.path.join(data_root, '/content/image_colorization_data/data/train_color')
train_black = os.path.join(data_root, '/content/image_colorization_data/data/train_black')
test_color = os.path.join(data_root, '/content/image_colorization_data/data/test_color')
test_black = os.path.join(data_root, '/content/image_colorization_data/data/test_black')

batch_size = 16
img_height, img_width = 256, 256

# --------------------------------------------------------------
# ðŸŒ€ Data Generator
# --------------------------------------------------------------
def image_batch_generator(color_dir, black_dir, img_height, img_width, batch_size):
    color_filenames = sorted([os.path.join(color_dir, fn) for fn in os.listdir(color_dir)])
    black_filenames = sorted([os.path.join(black_dir, fn) for fn in os.listdir(black_dir)])
    while True:
        for i in range(0, len(color_filenames), batch_size):
            batch_color, batch_black = [], []
            for cpath, bpath in zip(color_filenames[i:i+batch_size], black_filenames[i:i+batch_size]):
                c = tf.io.read_file(cpath)
                c = tf.image.decode_jpeg(c, channels=3)
                c = tf.image.resize(c, [img_height, img_width]) / 255.0
                batch_color.append(c)

                b = tf.io.read_file(bpath)
                b = tf.image.decode_jpeg(b, channels=1)
                b = tf.image.resize(b, [img_height, img_width]) / 255.0
                batch_black.append(b)
            yield np.array(batch_black), np.array(batch_color)

# --------------------------------------------------------------
# ðŸ§© Define the Model (U-Net style Autoencoder)
# --------------------------------------------------------------
def build_autoencoder(img_height, img_width):
    inputs = Input(shape=(img_height, img_width, 1))
    c1 = Conv2D(64, (3,3), padding='same', activation='relu')(inputs)
    p1 = MaxPool2D((2,2))(c1)
    c2 = Conv2D(32, (3,3), padding='same', activation='relu')(p1)
    p2 = MaxPool2D((2,2))(c2)
    c3 = Conv2D(16, (3,3), padding='same', activation='relu')(p2)
    p3 = MaxPool2D((2,2))(c3)

    encoded = Conv2D(8, (3,3), padding='same', activation='relu')(p3)

    u1 = UpSampling2D((2,2))(encoded)
    u1 = Conv2D(16, (3,3), padding='same', activation='relu')(u1)
    u1 = Concatenate()([u1, c3])
    u2 = UpSampling2D((2,2))(u1)
    u2 = Conv2D(32, (3,3), padding='same', activation='relu')(u2)
    u2 = Concatenate()([u2, c2])
    u3 = UpSampling2D((2,2))(u2)
    u3 = Conv2D(64, (3,3), padding='same', activation='relu')(u3)
    u3 = Concatenate()([u3, c1])

    outputs = Conv2D(3, (3,3), padding='same', activation='sigmoid')(u3)

    model = Model(inputs, outputs)
    model.compile(optimizer='adam', loss='mse')
    return model

# --------------------------------------------------------------
# ðŸš€ Train the Model
# --------------------------------------------------------------
dataset = image_batch_generator(train_color, train_black, img_height, img_width, batch_size)
autoencoder = build_autoencoder(img_height, img_width)
steps_per_epoch = len(os.listdir(train_color)) // batch_size
autoencoder.fit(dataset, steps_per_epoch=steps_per_epoch, epochs=20)

# --------------------------------------------------------------
# ðŸŽ¯ Test on One Image
# --------------------------------------------------------------
bnw_batch, color_batch = next(dataset)
single_bw = np.expand_dims(bnw_batch[0], axis=0)
pred = autoencoder.predict(single_bw)[0]

plt.figure(figsize=(10,3))
plt.subplot(1,3,1)
plt.imshow(bnw_batch[0].squeeze(), cmap='gray')
plt.title('Grayscale')
plt.axis('off')
plt.subplot(1,3,2)
plt.imshow(color_batch[0])
plt.title('Ground Truth')
plt.axis('off')
plt.subplot(1,3,3)
plt.imshow(pred)
plt.title('Predicted')
plt.axis('off')
plt.show()

# --------------------------------------------------------------
# ðŸ’¾ Save Model
# --------------------------------------------------------------
autoencoder.save('/content/drive/MyDrive/colorization_model.h5')

# --------------------------------------------------------------
# ðŸ§ƒ Colorize All Test Images
# --------------------------------------------------------------
out_folder = '/content/drive/MyDrive/colorized_results'
os.makedirs(out_folder, exist_ok=True)
black_list = sorted(os.listdir(test_black))

for fname in black_list:
    bpath = os.path.join(test_black, fname)
    b = tf.io.read_file(bpath)
    b = tf.image.decode_jpeg(b, channels=1)
    b = tf.image.resize(b, [img_height, img_width]) / 255.0
    b = tf.expand_dims(b, axis=0)
    pred = autoencoder.predict(b)[0]
    pred_img = (pred * 255).astype(np.uint8)
    imageio.imwrite(os.path.join(out_folder, fname), pred_img)

# --------------------------------------------------------------
# ðŸ–¼ï¸ Display a Few Colorized Outputs
# --------------------------------------------------------------
result_files = sorted(os.listdir(out_folder))
for fname in result_files[:5]:
    img_path = os.path.join(out_folder, fname)
    img = cv2.imread(img_path)
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    plt.figure(figsize=(4,4))
    plt.imshow(img)
    plt.title(fname)
    plt.axis('off')
    plt.show()

# --------------------------------------------------------------
# ðŸ“ˆ Evaluate SSIM and PSNR
# --------------------------------------------------------------
color_list = sorted(os.listdir(test_color))
pred_list = sorted(os.listdir(out_folder))
total_ssim = 0
total_psnr = 0

for cfile, pfile in zip(color_list, pred_list):
    c_img = cv2.imread(os.path.join(test_color, cfile))
    p_img = cv2.imread(os.path.join(out_folder, pfile))
    c_img = cv2.resize(c_img, (256, 256))
    p_img = cv2.resize(p_img, (256, 256))
    total_ssim += ssim(c_img, p_img, channel_axis=-1, data_range=255)
    total_psnr += psnr(c_img, p_img, data_range=255)

print("âœ… Average SSIM:", total_ssim / len(color_list))
print("âœ… Average PSNR:", total_psnr / len(color_list))

# --------------------------------------------------------------
# ðŸ“¦ Zip and Download Colorized Results
# --------------------------------------------------------------
!zip -r colorized_results.zip '/content/drive/MyDrive/colorized_results'
from google.colab import files
files.download('colorized_results.zip')